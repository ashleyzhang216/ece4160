---
layout: default
title: Lab 3
---
<div class="blurb">
	<h1>Lab 3</h1>

    <h2>Summary</h2>
    <p>
		During this lab, we investigated the use of filtering and fast fourier transform (FFT) analysis in order to implement 
		the remote start triggering of our robot by playing a specific note. In order to do this, we used a microphone which was 
		attached to an amplifer circuit, which was fed into our Arduino Nano Every. It performed FFT analysis which detects the 
		frequency of the note indicating that the robot should begin navigating the maze. In case this failed, however, we also 
		implemented a backup button which causes the same action. 
    </p>

    <h2>LT Spice Simulations</h2>
    <p>
		In order to understand the microphone circuit, we initially constructed two circuits in LT spice, a circuit simulation 
		software. We used this to analyze the cutoff frequencies corresponding to the low-pass and high-pass circuits we built. 
		Below you can find the circuit diagram and simulation graph we obtained from our low-pass circuit. We did this by using 
		an AC voltage source to analyze the behavior between 1kHz and 10kHz, for the 1.2 kilo Ohm resistor and 0.1 uF capacitor we used. 

		When the capacitor is without any charge, it initially acts as an open circuit, so as the frequency increases, its behavior 
		approaches resembling a short circuit. This causes signals with high frequencies to not be able to pass through. On the other 
		hand, when the frequency drops, the capacitor more closely represents an open circuit, allowing low-frequency signals to pass 
		through. You can see this in the plot below. Notice that the cutoff frequency for our low-pass circuit is around 1.3 kHz
    </p>
    <table>
        <tr>
            <th>Low-pass Circuit Schematic</th>
            <th>Low-pass Circuit Simulation</th>
        </tr>
        <tr>
            <td><img src="/ayz27/ayz27.github.io/media/lab3/lowpassfilter.png" height="250px"></td>
            <td><img src="/ayz27/ayz27.github.io/media/lab3/lowpasscutoff.JPG" height="250px"></td>
        </tr>
    </table>
	<p>
		In the second circuit, the high-pass circuit, we had a slightly different layout. While we still use the same components, with 
		the capacitor acting the same way with different frequencies, the capacitor and resistor are swapped. Because of this, with high 
		frequencies, the short circuit this component resembles causes Vout to go high, allowing high frequency signals to pass. With low 
		frequencies, instead Vout goes low, and low frequency signals cannot pass. Notice that the cutoff frequency for this circuit is 
		also around 1.3 kHz
    </p>
    <table>
        <tr>
            <th>Low-pass Circuit Schematic</th>
            <th>Low-pass Circuit Simulation</th>
        </tr>
        <tr>
            <td><img src="/ayz27/ayz27.github.io/media/lab3/high pass filter.png" height="275px"></td>
            <td><img src="/ayz27/ayz27.github.io/media/lab3/highpasscutoff.JPG" height="275px"></td>
        </tr>
    </table>

    <h2>Microphone Circuit</h2>
    <p>
		To be able to "hear" the note, we used an electric microphone to convert sound waves into signals. However, the signal we 
		received from this microphone was so small in amplitude that we built an amplifer circuit to make the sound more noticable and 
		easier to analyze. You can see the circuit diagram on the left, below, with our construction of it in our breadboard on the right. 
    </p>

	<table>
        <tr>
            <th>Circuit Diagram</th>
            <th>Breadboard Circuit</th>
        </tr>
        <tr>
            <td><img src="/ayz27/ayz27.github.io/media/lab3/amp_mic_schem.png" height="250px"></td>
            <td><img src="/ayz27/ayz27.github.io/media/lab3/mic_circuit.PNG" height="250px"></td>
        </tr>
    </table>

	<h2>Matlab Analysis</h2>
    <p>
		To analyze the data we received from both the old and new microphone circuits, we used FFT analysis in MATLAB to help us. However, in the future, this 
		code must be translated so that our Nano can run it during the demonstration so it can tell when to start moving. We used the Analog-to-Digital 
		Converter (ADC) to read the analog voltage output of our microphone circuit, into which we fed audio of a specific frequency note generated by MATLAB 
		code. The circuit's output was uniformly polled by the Nano for 256 data points at a frequency of 2.4 kHz. Then, we exported this data we just captured 
		to our MATLAB code for analysis. 
		
		Below you can see the results. On the left side is the original, unamplified circuit, with the right side being from our amplified circuit. 
		For each column there are two rows, with the first corresponding to the raw data showing the signal over time, and the bottom one being the 
		results of the fourier transform, with the frequencies being on the x-axis instead. Clearly, we can see that the amplifier circuit made it a lot 
		easier to identify and tell apart the particular frequency that is being played. 
    </p>
	<table>
		<caption>MATLAB data and results</caption>
        <tr>
            <th>Circuit Diagram</th>
            <th>Breadboard Circuit</th>
        </tr>
        <tr>
            <td><img src="/ayz27/ayz27.github.io/media/lab3/4.4.1 500hz.jpg" height="250px"></td>
            <td><img src="/ayz27/ayz27.github.io/media/lab3/4.4.2 amplified 500hz.jpg" height="250px"></td>
        </tr>
    </table>

    <h2>Arduino FFT</h2>
    <p>
		In order to be able to detect different frequency sounds on our robot, we needed to convert our MATLAB code to work on arduino. With the FFT library 
		that would create signal spectrums we installed, we used the ADC in free-running mode to continiously sample the output of our amplified microphone 
		circuit. Using the TCA, we configured interrupts to trigger every 0.41667 milliseconds, corresponding to the 2.4 kHz we mentioned earlier, so that 
		we can sample the signal (for 256 values of which we used 128) over a long enough period of time. With the help of MATLAB, we were able to see 
		where sample frequencies were in the different signals we tested. The highest peak in the graph had a bin number which we calculated using the 
		following method:  
    </p>
	<img src="/ayz27/ayz27.github.io/media/lab3/binfreq_eqn.png" height="100px">
	
	<p>
		You can see the results of our testing below for various frequencies. 
	</p>
    
	<table>
        <tr>
            <th>500 Hz</th>
            <th>700 Hz</th>
			<th>900 Hz</th>
        </tr>
        <tr>
            <td><img src="/ayz27/ayz27.github.io/media/lab3/500 Hz Spectrum.png" height="200px"></td>
            <td><img src="/ayz27/ayz27.github.io/media/lab3/700 Hz Spectrum.png" height="200px"></td>
            <td><img src="/ayz27/ayz27.github.io/media/lab3/900 Hz Spectrum.png" height="200px"></td>
        </tr>
    </table>

	<h2>Override Button</h2>
	<p>
		In case something goes wrong, we wanted to have the ability to manually start our robot. We did this using an override button, which would tell our robot 
		to just start navigating the maze, skipping detecting the note with the designated frequency. This was accomplished by using a button with a pullup 
		resistor attached to it, and attaching an interrupt to the pin connected to the output to trigger when the signal fell. Then, during the interrupt service 
		routine (ISR) that executed, we could instruct our robot to execute the above instructions. A picture of our circuit is below. 
	</p>
	<img src="/ayz27/ayz27.github.io/media/lab3/overridebutton.PNG" height="250px">

</div><!-- /.blurb -->