---
layout: default
title: Lab 2
---
<div class="blurb">
	<h1>Lab 2</h1>

    <h2>Preview and Code Restructuring</h2>
    <p>
        In this lab, we integrated the ICM-20948 IMU sensor into our Artemis board. Following the setup instructions for the IMU was very 
        straightforward, and no major issues were run into during the programming of the board with a test script. However, during this time, 
        I added a major code restructuring into the Arduino script. Previously, the primary .ino file was the provided arduino_ble.ino, but this 
        wasn't ideal to me since structuring around BLE made it difficult to add or change board functionality. Inspired by my previous experience 
        building and maintaining C++ projects, I changed arduino_ble into a header file, and defined a completely different main.ino file. setup() 
        and loop() in arduino_ble simply became ble_setup() and ble_loop(), and these were essentially the only thing called inside the main.ino file 
        before integrating the IMU further. This was done from the beginning since I anticipated much more difficulty if I had attemped this restructuring 
        when it was required later on in the lab. To complete the earlier sections of the lab, I simply added another imu_setup() (defined in a new header file 
        dedicated to the IMU) and imu_loop(), and selectively commented out the loop I didn't want to execute. 
    </p>

    <h2>Adding the IMU</h2>
    <p>
		Installing the IMU library in the Arduino IDE went smoothly. I initially just uploaded the script directly to the Artemis, but was confused when 
        the Artemis wasn't able to properly connect to the IMU. Turns out, I had overlooked AD0_VAL. Reading the comments in the provided example code, I 
        inspected the IMU and found that since the ADR jumper was closed, AD0_VAL should be set to 0. Adding this change to my code resulted in a functioning 
        IMU and data printed to console. 
    </p>
    <p>
        After experimenting a bit with the IMU, I found all the sensor data to be relatively accurate. Acceleration changed when I moved the IMU around, and by 
        testing, I figured out how the axes of the IMU aligned with the physical board. Likewise, gyro data was non-neglible when I was actively rotating the IMU 
        about some axis. However, the magnetometer was a little trickier to get meaningful data out of it. However, I eventually figured out that bringing the 
        IMU closer to electronically noisy things like my laptop or phone could induce large changes in the data. 
    </p>
    <table>
        <tr>
            <th>Test Script</th>
            <th>AD0_VAL</th>
        </tr>
        <tr>
            <td><video height="200px" controls><source src="https://ashleyzhang216.github.io/ece4160/media/lab2/IMG_0991.MOV">Your browser does not support this video format.</video></td>
            <td><img src="https://ashleyzhang216.github.io/ece4160/media/lab2/AD0_VAL.png" height="200px"></td>
        </tr>
    </table>

    <h2>Getting Pitch and Roll</h2>
    <p>
        Next, I refreshed myself with the pitch and roll equations from class. Taking advantage of the fact that gravity will always point down, I rederived the equations 
        given on the slides in class. Using atan2() as suggested, I implemented roll as being atan2 with X-direction acceleration over Z-direction acceleration, and pitch as 
        being atan2 with Y-direction acceleration over Z-direction acceleration. Note that not included in the screenshot is a helper function I added to convert between degrees 
        and radians, to make my code more readable. 
    </p>

	<table>
        <tr>
            <th>Pitch and Roll Functions</th>
        </tr>
        <tr>
            <td><img src="https://ashleyzhang216.github.io/ece4160/media/lab2/pitch_roll_func.png" height="200px"></td>
        </tr>
    </table>

    <p>
        Next, I tested the limits of the system. For both pitch and roll, I've included screenshots of the serial monitor output when holding the IMU at -90, 0, and 90 degrees. 
        Overall, I found the sensor to be very accurate. I had expected much more variance in data around 90 degrees since the axes would be perpendicular to the floor, and thus 
        any noise in the raw acceleration data could cause large swings in pitch and roll output data. However, I found my sensor to be remarkably resilient to this. I, for one, 
        am definitely not complaining about not needing a two-point calibration.  
    </p>

    <table>
        <tr>
            <th>Pitch @ -90</th>
            <th>Pitch @ 0</th>
            <th>Pitch @ 90</th>
        </tr>
        <tr>
            <td><img src="https://ashleyzhang216.github.io/ece4160/media/lab2/pitch_-90.png" height="200px"></td>
            <td><img src="https://ashleyzhang216.github.io/ece4160/media/lab2/pitch_0.png" height="200px"></td>
            <td><img src="https://ashleyzhang216.github.io/ece4160/media/lab2/pitch_90.png" height="200px"></td>
        </tr>
        <tr>
            <th>Roll @ -90</th>
            <th>Roll @ 0</th>
            <th>Roll @ 90</th>
        </tr>
        <tr>
            <td><img src="https://ashleyzhang216.github.io/ece4160/media/lab2/roll_-90.png" height="200px"></td>
            <td><img src="https://ashleyzhang216.github.io/ece4160/media/lab2/roll_0.png" height="200px"></td>
            <td><img src="https://ashleyzhang216.github.io/ece4160/media/lab2/roll_90.png" height="200px"></td>
        </tr>
    </table>

	<table>
        <tr>
            <th>Serial Output</th>
        </tr>
        <tr>
            <td><img src="/ayz27/ayz27.github.io/media/lab2/serial.jfif" height="200px"></td>
        </tr>
    </table>

    <h2>7 Segment Display</h2>
    <p>
        In order to display the proper values during our demo, we need a 7 segment display with 4 digits to display the frequency we measure. We worked on programming 
		this with the Nano, a 74HC595 shift register, 2N3906 transistors, and current limiting resistors. With this setup, we can decrease the number of GPIO pins we 
		need to acomplish the task. Even though we can only light one digit at a time, the purpose of the shift register was to allow us to light each digit in order, 
		and have it passed to the shift register which would send it to the display. Even though the LEDs are only on for a brief period of time, if we cycle every 5ms, 
		the LEDs glow for a short period that is long enough that we see all digits at once. Here are some examples of this phenomenon in action. 
    </p>
    
	<table>
        <tr>
            <th>28</th>
            <th>246</th>
			<th>248</th>
            <th>468</th>
			<th>2468</th>
        </tr>
        <tr>
            <td><img src="/ayz27/ayz27.github.io/media/lab2/28.jfif" height="200px"></td>
            <td><img src="/ayz27/ayz27.github.io/media/lab2/246.jfif" height="200px"></td>
            <td><img src="/ayz27/ayz27.github.io/media/lab2/248.jfif" height="200px"></td>
			<td><img src="/ayz27/ayz27.github.io/media/lab2/468.jfif" height="200px"></td>
			<td><img src="/ayz27/ayz27.github.io/media/lab2/2468.jfif" height="200px"></td>
        </tr>
    </table>

</div><!-- /.blurb -->